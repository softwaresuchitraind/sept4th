UPDATE PERSON SET FIRST_NAME = 'RAMANA',AGE = 33 WHERE ID = 6;
* n Number of rows can be updated by using comma as a separator.

UPDATE PERSON SET ID = 25,AGE = 38 WHERE ID = 7;
2 ROWS UPDATED.

UPDATE PERSON SET AGE = 28 WHERE AGE IS NULL;
UPDATE PERSON SET AGE = 38 WHERE FIRST_NAME IS NOT  NULL;
UPDATE PERSON SET FIRST_BAME = 'ANU' WHERE ID > 4;
UPDATE PERSON SET AGE = 22, ID = 10 WHERE ID <= 7;
UPDATE PERSON SET AGE = 22, ID = 15;
DELETE FROM PERSON WHERE ID = 6;
DELETE FROM PERSON WHERE FIRST_NAME = 'MURALI';
DELETE FROM PERSON WHERE FIRST_NAME = 'KUMAR';
DELETE FROM PERSON WHERE FIRST_NAME = 'ANU';
DELETE FROM PERSON;

DIFERNCE BETWEEN DELETE AND TRUCATE.
-tRUCANTE IS DDL, DETELTE IS DML. IN CASE OF DELTE WE CAN RETRIVE BACK.
TRUCATE WE CAN NOT RETRIVE DATA IN TRANSACTION CONTEXT.

DETETE AND TRUCATE ONLY FOR REMOVING DATA FROM TABLE.
TABLE ITSELF IS NOT REMOVING.

DROP TABLE PERSON;

* Table will be dropped
c-10/04
n-11/04
-----------------------------------------------------------------

CREATE TABLE EMPLOYEE(ID NUMBER,
		FIRST_NAME VARCHAR2(90),
		LAST_NAME VARCHAR2(90),
		AGE NUMBER,
		SALARY NUMBER,
		EMAIL VARCHAR2(90));

INSERT INTO EMPLOYEE VALUES(1,'RAMU','BTM',22,4000,'R@G.IN');
INSERT INTO EMPLOYEE VALUES(2,'RAVI','RAO',24,3000,'R@G.IN');
INSERT INTO EMPLOYEE VALUES(3,'MANU','BTM',23,5000,'M@G.IN');
INSERT INTO EMPLOYEE VALUES(4,'MURALI','RAO',26,5500,'M@G.IN');
INSERT INTO EMPLOYEE VALUES(5,'RAGHU','JD',25,2000,'R@G.IN');
INSERT INTO EMPLOYEE VALUES(6,'PAVAN','NAO',28,3500,'P@G.IN');
INSERT INTO EMPLOYEE VALUES(7,'ANU','JP',21,6000,'A@G.IN');
INSERT INTO EMPLOYEE VALUES(8,'SWETHA','NAO',29,5600,'W@G.IN');
INSERT INTO EMPLOYEE VALUES(9,'SUNITHA','JD',32,7000,'SU@G.IN');
INSERT INTO EMPLOYEE VALUES(10,'KIRAN','JP',30,5300,'k@G.IN');


SELECT
------
To read the data.

SELECT * FROM EMPLOYEE;
* represents every column.

SELECT * FROM EMPLOYEE WHERE ID =5;
SELECT * FROM EMPLOYEE WHERE ID>5;
SELECT * FROM EMPLOYEE WHERE AGE BETWEEN 22 AND 28;
SELECT * FROM EMPLOYEE WHERE AGE NOT BETWEEN 22 AND 28;
SELECT * FROM EMPLOYEE WHERE SALARY IN (4000,5500,7000);
SELECT * FROM EMPLOYEE WHERE SALARY NOT IN (4000,5500,7000);
SELECT * FROM EMPLOYEE WHERE FIRST_NAME LIKE '%R%';
SELECT FIRST_NAME,AGE FROM EMPLOYEE;
SELECT FIRST_NAME,AGE,LAST_NAME FROM EMPLOYEE;
SELECT FIRST_NAME AS MYNAME,AGE,LAST_NAME FROM EMPLOYEE;
SELECT FIRST_NAME AS MYNAME,AGE AS MYAGE,LAST_NAME FROM EMPLOYEE;
SELECT FIRST_NAME AS MYNAME,AGE ,LAST_NAME FROM EMPLOYEE;
SELECT FIRST_NAME AS MYNAME,AGE MYAGE ,LAST_NAME FROM EMPLOYEE;

SELECT COUNT(*) FROM EMPLOYEE;
SELECT COUNT(*) AS "RECORDS COUNT" FROM EMPLOYEE;
SELECT COUNT(*)  "RECORDS COUNT" FROM EMPLOYEE;
SELECT COUNT(LAST_NAME) "RECORDS COUNT" FROM EMPLOYEE;


SELECT MAX(AGE) FROM EMPLOYEE;
SELECT MAX(AGE) AS "MAX AGE" FROM EMPLOYEE;
SELECT MAX(AGE)  "MAX AGE" FROM EMPLOYEE;

SELECT MIN(SALARY) FROM EMPLOYEE;
SELECT MIN(SALARY) MIN_SAL FROM EMPLOYEE;
SELECT MIN(SALARY) 'MIN_SAL" FROM EMPLOYEE;

SELECT AVG(SALARY) FROM EMPLOYEE;
SELECT AVG(SALARY) "AVG SALARY" FROM EMPLOYEE;
SELECT AVG(AGE) "AVG AGE" FROM EMPLOYEE;
SELECT MIN(FIRST_NAME) FROM EMPLOYEE;
SELECT MAX(FIRST_NAME) FROM EMPLOYEE;

SELECT * FROM EMPLOYEE ORDER BY FIRST_NAME;
SELECT * FROM EMPLOYEE ORDER BY AGE;
SELECT * FROM EMPLOYEE ORDER BY SALARY;
SELECT * FROM EMPLOYEE ORDER BY AGE,SALARY;

//SELECT FIRST_NAME, MAX(SALARY) FROM EMPLOYEE;

SELECT FIRST_NAME FROM EMPLOYEE WHERE SALARY =
(SELECT MAX(SALARY) FROM EMPLOYEE);

SELECT FIRST_NAME FROM EMPLOYEE WHERE AGE =
(SELECT MAX(AGE) FROM EMPLOYEE);

SELECT FIRST_NAME FROM EMPLOYEE WHERE AGE =
(SELECT MIN(AGE) FROM EMPLOYEE);


SELECT FIRST_NAME FROM EMPLOYEE WHERE SALARY <
(SELECT AVG(SALARY) FROM EMPLOYEE);


SELECT MAX(SALARY) FROM EMPLOYEE
WHERE SALARY<(SELECT MAX(SALARY) FROM EMPLOYEE);

SELECT MIN(SALARY) FROM EMPLOYEE
WHERE SALARY>(SELECT MIN(SALARY) FROM EMPLOYEE);

SELECT FIRST_NAME FROM EMPLOYEE WHERE SALARY =
(SELECT MAX(SALARY) FROM EMPLOYEE
WHERE SALARY <(SELECT MAX(SALARY) FROM EMPLOYEE));


SELECT FIRST_NAME FROM EMPLOYEE WHERE SALARY =
(SELECT MIN(SALARY) FROM EMPLOYEE
WHERE SALARY >(SELECT MIN(SALARY) FROM EMPLOYEE));


SELECT ID, FIRST_NAME, LAST_NAME, AGE, SALARY, EMAIL,
RANK() OVER (ORDER BY SALARY DESC) RANK FROM EMPLOYEE;


SELECT * FROM (SELECT ID, FIRST_NAME, LAST_NAME, AGE, SALARY,
EMAIL, RANK() OVER (ORDER BY SALARY DESC) RANK FROM EMPLOYEE)
WHERE RANK = 3;

SELECT * FROM (SELECT ID, FIRST_NAME, LAST_NAME, AGE, SALARY,
EMAIL, RANK() OVER(ORDER BY SALARY DESC) RANK FROM EMPLOYEE)
WHERE RANK = 5;

C-11/4
A-12/4
-------------


INSERT INTO EMPLOYEE VALUES(1,'RAMU','BTM',22,4000,'R@G.IN');
INSERT INTO EMPLOYEE VALUES(2,'RAVI','RAO',24,3000,'R@G.IN');
INSERT INTO EMPLOYEE VALUES(3,'MANU','BTM',23,5000,'M@G.IN');
INSERT INTO EMPLOYEE VALUES(4,'MURALI','RAO',26,5500,'M@G.IN');
INSERT INTO EMPLOYEE VALUES(5,'RAGHU','JD',25,2000,'R@G.IN');
INSERT INTO EMPLOYEE VALUES(6,'PAVAN','NAO',28,3500,'P@G.IN');
INSERT INTO EMPLOYEE VALUES(7,'ANU','JP',21,6000,'A@G.IN');
INSERT INTO EMPLOYEE VALUES(8,'SWETHA','NAO',29,5600,'W@G.IN');
INSERT INTO EMPLOYEE VALUES(9,'SUNITHA','JD',32,7000,'SU@G.IN');
INSERT INTO EMPLOYEE VALUES(10,'KIRAN','JP',30,5300,'k@G.IN');



INSERT INTO EMPLOYEE VALUES(1,'RAMU','BTM',22,4000,'R@G.IN');
INSERT INTO EMPLOYEE VALUES(2,'RAVI','RAO',24,3000,'R@G.IN');
INSERT INTO EMPLOYEE VALUES(3,'MANU','BTM',23,5000,'M@G.IN');
INSERT INTO EMPLOYEE VALUES(4,'MURALI','RAO',26,5500,'M@G.IN');
INSERT INTO EMPLOYEE VALUES(5,'RAGHU','JD',25,2000,'R@G.IN');
INSERT INTO EMPLOYEE VALUES(6,'PAVAN','NAO',28,3500,'P@G.IN');
INSERT INTO EMPLOYEE VALUES(7,'ANU','JP',21,6000,'A@G.IN');
INSERT INTO EMPLOYEE VALUES(8,'SWETHA','NAO',29,5600,'W@G.IN');
INSERT INTO EMPLOYEE VALUES(9,'SUNITHA','JD',32,7000,'SU@G.IN');
INSERT INTO EMPLOYEE VALUES(10,'KIRAN','JP',30,5300,'k@G.IN');


SELECT * FROM EMPLOYEE;


-Each record duplicated three times.

SELECT ID, FIRST_NAME, LAST_NAME, AGE, EMAIL, SALARY, ROWID FROM EMPLOYEE;
SELECT ID, FIRST_NAME, LAST_NAME, AGE, EMAIL, SALARY, ROWNUM FROM EMPLOYEE;


-Every row containing one unique row-id.
-Every row containing ---sequentional number(Rownum)

SELECT * FROM EMPLOYEE WHERE ROWNUM BETWEEN 10 AND 20;

SELECT * FROM (SELECT ID, FIRST_NAME, LAST-NAME, AGE,
		EMAIL,SALARY,ROWNUM AS RN FROM EMPLOYEE)
		WHERE RN <= 10;


-ROWNUM is not in the Employee Table so make virtual table.


SELECT * FROM (SELECT ID, FIRST_NAME, LAST-NAME, AGE,
		EMAIL,SALARY,ROWNUM AS RN FROM EMPLOYEE)
		WHERE RN BETWEEN 11 AND 28;

ROWNUM--- Pagination purpose--chosing multiple pages to the select command.



SELECT * FROM (SELECT ID, FIRST_NAME, LAST-NAME, AGE,
		EMAIL,SALARY,ROWNUM AS RN FROM EMPLOYEE)
		WHERE RN BETWEEN 11 AND 28;

SELECT ID, FIRST_NAME, LAST_NAME, AGE, EMAIL, SALARY FROM EMPLOYEE;

-every record is duplicated three times.


SELECT DISTINCT ID, FIRST_NAME, LAST_NAME, AGE, EMAIL, SALARY FROM EMPLOYEE;


SELECT * FROM EMPLOYEE GROUP BY
		ID, FIRST_NAME, LAST_NAME, AGE, EMAIL, SALARY;

Removing dulpicates permanently.---ROWID/ GROUP BY

DELETE FROM EMPLOYEE WHERE ROWID NOT IN
(SELECT MIN(ROWID) FROM EMPLOYEE GROUP BY
	ID, FIRST_NAME, LAST_NAME, AGE, EMAIL, SALARY);


DELETE FROM EMPLOYEE WHERE ROWID NOT IN
(SELECT MAX(ROWID) FROM EMPLOYEE GROUP BY
	ID, FIRST_NAME, LAST_NAME, AGE, EMAIL, SALARY);

SELECT ID, FIRST_NAME, LAST-NAME, AGE
	EMAIL, SALARY, ROWID FROM EMPLOYEE;


SELECT MIN(ROWID) FROM EMPLOYEE;
SELECT MAX(ROWID) FROM EMPLOYEE;

c-12/04
-----------

DROP TABLE TAB1;
CREATE TABLE TAB1(ID NUMBER, NAME VARCHAR2(90), AGE NUMBER);
INSERT INTO TAB1(ID) VALUE(1);
INSERT INTO TAB1(ID, NAME) VALUES(2, 'ABC');
INSERT INTO TAB1(ID, AGE) VALUES(3,33);
INSERT INTO TAB1(NAME,AGE) VALUES ('RAMU', 44);
INSERT INTO TAB1(NAME) VALUES ('MANU');
INSERT INTO TAB1(AGE) VALUES(25);

SELECT * FROM TAB1;

- By default every column is allowing null value --it can be numeric or varchar


How to create a table that column should not contain null values ?

DROP TABLE TAB2;

CREATE TABLE TAB2(ID NUMBER,
		   NAME VARCHAR2(90) NOT NULL,
		   AGE NUMBER);
INSERT INTO TAB2(ID) VALUES(1); //ERROR
INSERT INTO TAB2(ID, NAME) VALUES (2, 'ABC');
INSERT INTO TAB2(ID,AGE) VALUES(3,33); //ERROR
INSERT INTO TAB2(NAME,AGE) VALUES ('RAMU', 44);
INSERT INTO TAB2(NAME) VALUES ('MANU');
INSERT INTO TAB2(AGE) VALUES (25); //ERROR
SELECT * FROM TAB2;

* Same table can have any number of NOT NULL columns

DROP TABLE TAB3;
CREATE TABLE TAB3(ID NUMBER NOT NULL,
		 NAME VARCHAR2(90) NOT NULL,
		 AGE NUMBER);
INSERT INTO TAB3(ID) VALUES(1);//ERROR
INSERT INTO TAB3(ID,NAME) VALUES(2, 'ABC');
INSERT INTO TAB3(ID,AGE) VALUES(3,33); //ERROR
INSERT INTO TAB3(NAME,AGE) VALUES('RAMU',44); //ERROR
INSERT INTO TAB3(NAME) VALUES('MANU'); //ERROR
INSERT INTO TAB3(AGE) VALUES(25); //ERROR
SELECT * FROM TAB3;

DROP TABLE TAB4;
CREATE TABLE TAB4(ID NUMBER,
		NAME VARCHAR2(90),
		AGE NUMBER);
INSERT INTO TAB4(ID,NAME) VALUES(1,'MANU');
INSERT INTO TAB4(ID,NAME) VALUES(1,'MANU');
INSERT INTO TAB4(ID,NAME,AGE) VALUES(1,'RAMU',22);
INSERT INTO TAB4(ID,NAME,AGE) VALUES(1,'RAMU',22);
INSERT INTO TAB4(NAME,AGE) VALUES('RAMU',22);
INSERT INTO TAB4(NAME,AGE) VALUES('RAMU',22);

DROP TABLE TAB5;
CREATE TABLE TAB5(ID NUMBER,
		NAME VARCHAR2(90) UNIQUE,
		AGE NUMBER);

INSERT INTO TAB5(ID,NAME) VALUES(1,'MANU');
INSERT INTO TAB5(ID,NAME) VALUES(1,'MANU');//error
INSERT INTO TAB5(ID,NAME,AGE) VALUES(1,'RAMU',22);
INSERT INTO TAB5(ID,NAME,AGE) VALUES(1,'RAMU',22);//error
INSERT INTO TAB5(NAME,AGE) VALUES('RAMU',22);//error
INSERT INTO TAB5(NAME,AGE) VALUES('RAMU',22);//error
INSERT INTO TAB5(ID,AGE) VALUES (5,22);
INSERT INTO TAB5(ID,AGE) VALUES (5,22);
INSERT INTO TAB5(ID) VALUES (5);
INSERT INTO TAB5(AGE) VALUES (25);
SELECT * FROM TAB5;

-by default column is allowing duplicate values
-UNIQUE----u can not enter a duplicate value--multiple nulll value can be allowed.
-Any number of Columns can be declared as unique.

DROP TABLE TAB6;
CREATE TABLE TAB6(ID NUMBER
		NAME VARCHAR2(90) UNIQUE
		AGE NUMBER UNIQUE);
INSERT INTO TAB6(ID,NAME) VALUES(1, 'MANU');
INSERT INTO TAB6(ID,NAME) VALUES(1, 'MANU');//ERROR
INSERT INTO TAB6(ID,NAME,AGE) VALUES(2, 'RAMU',22);
INSERT INTO TAB6(ID,NAME,AGE) VALUES(2, 'RAMU',22);//ERROR
INSERT INTO TAB6(NAME,AGE) VALUES('RAMU',22);//ERROR
INSERT INTO TAB6(NAME,AGE) VALUES('RAMU',22);//ERROR
INSERT INTO TAB6(ID,AGE) VALUES(5,22);//ERROR
INSERT INTO TAB6(ID,AGE) VALUES(5,22);//ERROR
INSERT INTO TAB6(ID) VALUES(5);
INSERT INTO TAB6(AGE) VALUES(25);
SELECT * FROM TAB6;
-UNIQUE----u can not enter a duplicate value--multiple nulll value can be allowed.
* two nulls is not considered as duplicate.

DROP TABLE TAB7;
CREATE TABLE TAB7(ID NUMBER,
		NAME VARCHAR2(90),
		AGE NUMBER,
CONSTRAINT TAB7_UK2 UNIQUE(NAME),
CONSTRAINT TAB7_UK2 UNIQUE(AGE));


INSERT INTO TAB7(ID,NAME) VALUES(1, 'MANU');
INSERT INTO TAB7(ID,NAME) VALUES(1, 'MANU');//ERROR
INSERT INTO TAB7(ID,NAME,AGE) VALUES(2, 'RAMU',22);
INSERT INTO TAB7(ID,NAME,AGE) VALUES(2, 'RAMU',22);//ERROR
INSERT INTO TAB7(NAME,AGE) VALUES('RAMU',22);//ERROR
INSERT INTO TAB7(NAME,AGE) VALUES('RAMU',22);//ERROR
INSERT INTO TAB7(ID,AGE) VALUES(5,22);//ERROR
INSERT INTO TAB7(ID,AGE) VALUES(5,22);//ERROR
INSERT INTO TAB7(ID) VALUES(5);
INSERT INTO TAB7(AGE) VALUES(25);
SELECT * FROM TAB7;

-name of the constraint should be unique across the tables.
-same constraint name can not be used even in another table also.
-whenver u want u can disable or drop constraint any time.
-Through alter command u can drop any constraint.

DROP TABLE TAB8;
CREATE TABLE TAB8(ID NUMBER,
		NAME VARCHAR2(90),
		AGE NUMBER,
CONSTRAINT TAB8_UK1 UNIQUE(NAME,AGE));
INSERT INTO TAB8(ID,NAME) VALUES(1,'MANU');
INSERT INTO TAB8(ID,NAME) VALUES(1,'MANU');//ERROR
INSERT INTO TAB8(ID,NAME,AGE) VALUES(2,'RAMU',22);
INSERT INTO TAB8(ID,NAME,AGE) VALUES(2,'RAMU',23);
INSERT INTO TAB8(ID,NAME,AGE) VALUES(2,'AMU',23);
INSERT INTO TAB8(NAME,AGE) VALUES('RAMU',22);//ERROR
INSERT INTO TAB8(NAME,AGE) VALUES('RAMU',22);//ERROR
INSERT INTO TAB8(ID,AGE) VALUES(5,22);//ERROR
INSERT INTO TAB8(ID,AGE) VALUES(5,22);//ERROR
INSERT INTO TAB8(ID) VALUES(5);
INSERT INTO TAB8(AGE) VALUES(25);
SELECT * FROM TAB8;

-If any unique key is on more than one column that is called composite key.
composite ---name+age
-combination of any two should not be same
-at least name or age should be change.
-combination of more than one column.
-in case of composite key combiantion should not be same null+ramu ,null+ramu not allowed.

16/04/2018
-----------

DROP TABLE TAB9;
CREATE TABLE TAB9(ID NUMBER
		NAME VARCHAR2(90) PRIMARY KEY,
		AGE NUMBER);
INSERT INTO TAB9(ID,NAME) VALUES(1,'MANU');
INSERT INTO TAB9(ID,NAME) VALUES(1,'MANU');//ERROR
INSERT INTO TAB9(ID,NAME,AGE) VALUES(2,'RAMU',22);
INSERT INTO TAB9(ID,NAME,AGE) VALUES(2,'RAMU',22);//ERROR
INSERT INTO TAB9(NAME,AGE) VALUES('RAMU',22);//ERROR
INSERT INTO TAB9(NAME,AGE) VALUES('RAMU',22);//ERROR
INSERT INTO TAB9(ID,AGE) VALUES(5,22);//ERROR
INSERT INTO TAB9(ID,AGE) VALUES(5,22);//ERROR
INSERT INTO TAB9(ID) VALUES(5);//ERROR
INSERT INTO TAB9(AGE) VALUES(25);//ERROR
INSERT INTO TAB9(NAME) VALUES('VIJAY');
SELECT * FROM TAB9;

PRIMARY KEY----donot allow duplicates + do not allow null values.

CREATE TABLE TAB10(ID NUMBER,
		NAME VARCHAR2(90) PRIMARY KEY,
		AGE NUMBER PRIMARY KEY);
*Table should not have more than one primary key.
-If u are attempting to more than one primary key then it eads to error.
-Primary key maximum one.
-Table can have any number of unique keys.

CREATE TABLE TAB11(ID NUMBER
		NAME VARCHAR2(90),
		AGE NUMBER,
CONSTRAINT TAB11_PK1 PRIMARY KEY(AGE));

INSERT INTO TAB11(ID,NAME) VALUES(1,'MANU');//ERROR
INSERT INTO TAB11(ID,NAME) VALUES(1,'MANU');//ERROR
INSERT INTO TAB11(ID,NAME,AGE) VALUES(2,'RAMU',22);
INSERT INTO TAB11(ID,NAME,AGE) VALUES(2,'RAMU',22);//ERROR
INSERT INTO TAB11(NAME,AGE) VALUES('RAMU',22);//ERROR
INSERT INTO TAB11(NAME,AGE) VALUES('RAMU',28);
INSERT INTO TAB11(ID,AGE) VALUES(5,22);//ERROR
INSERT INTO TAB11(ID,AGE) VALUES(5,28);//ERROR
INSERT INTO TAB11(ID) VALUES(5);//ERROR
INSERT INTO TAB11(AGE) VALUES(25);//ERROR
INSERT INTO TAB11(NAME) VALUES('VIJAY');//ERROR
SELECT * FROM TAB11;

composite primary key
---------------------

CREATE TABLE TAB12(ID NUMBER,
		NAME VARCHAR2(90),
		AGE NUMBER,
CONSTRAINT TAB12_PK1 PRIMARY KEY(AGE, NAME));
INSERT INTO TAB12 VALUES(1, 'ABC', 22);
INSERT INTO TAB12 VALUES(1, 'ABC', 22);//ERROR
INSERT INTO TAB12 VALUES(3, 'ABC', 23);
INSERT INTO TAB12 VALUES(4, 'ABC1', 23);
INSERT INTO TAB12(ID,NAME) VALUES(5, 'XYZ'); //ERROR
INSERT INTO TAB12(ID,AGE) VALUES(6, 33); //ERROR

-if primary key is on multiple columns then it is called as composite primary key.
-in the composite primary key no column can be a null.
-combination of name and age should not be same for two columns.

Differnce btewwen unique and pk.
-unique allows any number of null values --primary wont allow even single null values.
-table can have any number of unique columns------independently any number of columns .
-table can have maximum one primary key--can be single or composite primary key.

foreign key constraints
----------------------------


CREATE TABLE STUDENT(ID NUMBER UNIQUE,
		FIRST_NAME VARCHAR2(90),
		LAST_NAME VARCHAR2(90),
		AGE NUMBER,
		EMAIL VARCHAR2(90));

CREATE TABLE ADDRESS(HOUSE_NO VARCHAR2(90),
		STREET_NAME VARCHAR2(90),
		CITY VARCHAR2(90),
		STATE VARCHAR2(90),
		STUDENT_ID NUMBER,
CONSTRAINT ADDRESS_FK1 FOREIGN KEY(STUDENT_ID)
		REFERENCES STUDENT(ID));

INSERT INTO STUDENT VALUES(1, 'RAMU', 'B', 22, 'R@R.COM');
INSERT INTO ADDRESS VALUES(123/B, 'BTM', BLR, 'KAR', 1);

INSERT INTO STUDENT VALUES(2, 'MANU', 'B', 24, 'M@R.COM');
INSERT INTO ADDRESS VALUES(123/C, 'JPN', BLR, 'KAR', 2);

INSERT INTO STUDENT VALUES(3, 'VIJAY', 'B', 26, 'V@R.COM');
INSERT INTO ADDRESS VALUES(123/V, 'JN', BLR, 'KAR', 3);

INSERT INTO ADDRESS VALUES(123/R, 'JN', BLR, 'KAR', 4);//ERROR

INSERT INTO STUDENT VALUES(4, 'MURALI', 'B', 26, 'M@R.COM');
INSERT INTO ADDRESS VALUES(123/V, 'JN', BLR, 'KAR', 4);

DELETE FROM STUDENT WHERE ID =4;//error

DELETE FROM ADDRESS WHERE STUDENT_ID = 4;
DELETE FROM STUDENT WHERE ID= 4;

DELETE FROM STUDENT;//ERROR

DELETE FROM ADDRESS;
DROP TABLE STUDENT; //ERROR



condition--foreign key
-----------------------

1-to whichever column foreign key refering to that column should be unique or primary --to
avoid ambiguity.
2-foreign key value should be one of the value to refering column.
3-we can not delete parent record unless child record is removed.<Integrity constraints>
4--u can not remove parent table unless child table is removed.

19/04
---------

DROP TABLE ADDRESS;
DROP TABLE STUDENT;

CREATE TABLE STUDENT(ID NUMBER,
		FIRST_NAME VARCHAR2(90),
		LAST_NAME VARCHAR2(90),
		AGE NUMBER,
		EMAIL VARCHAR2(90));


CREATE TABLE ADDRESS(HOUSE_NO VARCHAR2(90),
		STREET_NAME VARCHAR2(90),
		CITY VARCHAR2(90),
		STATE VARCHAR2(90),
		STUDENT_ID NUMBER,
CONSTRAINT ADDRESS_FK1 FOREIGN KEY(STUDENT_ID)
		REFERENCES STUDENT(ID));//error

-in order to create a forein key it should refer parent table one column which is primary key
or uinque.

DROP TABLE STUDENT;

CREATE TABLE STUDENT(ID NUMBER UNIQUE,
		FIRST_NAME VARCHAR2(90),
		LAST_NAME VARCHAR2(90),
		AGE NUMBER,
		EMAIL VARCHAR2(90));

CREATE TABLE ADDRESS(HOUSE_NO VARCHAR2(90),
		STREET_NAME VARCHAR2(90),
		CITY VARCHAR2(90),
		STATE VARCHAR2(90),
		STUDENT_ID NUMBER,
CONSTRAINT ADDRESS_FK1 FOREIGN KEY(STUDENT_ID)
			REFERNCES STUDENT(ID));


INSERT INTO STUDENT VALUES(1, 'RAMU', 'B', 22,'R@GMAIL.COM');
INSERT INTO ADDRESS(HOUSE_NO,STREET_NAME,CITY,STATE)
		VALUES('123/T', 'BTM', 'BLR', 'KAR');

UPDATE ADDRESS SET STUDENT_ID = 3 WHERE HOUSE_NO = '123/T';//ERROR
UPDATE ADDRESS SET STUDENT_ID = 1 WHERE HOUSE_NO = '123/T';

INSERT INTO STUDENT(FIRST_NAME, LAST_NAME, AGE, EMAIL)
		VALUES('MANU', 'B', 22, 'R@GMAIL.COM');
INSERT INTO ADDRESS(HOUSE_NO, STREET_NAME, CITY, STATE)
		VALUES('123/Y', 'BTM', 'BLR', 'KAR');


-u can insert null value to foren key column later u can update after specifying
parent table.

- reference to the value only not null.

DROP TABLE PERSON;
CREATE TABLE PERSON(ID NUMBER PRIMARY KEY,
		FIRST_NAME VARCHAR2(90),
		LAST_NAME VARCHAR2(90),
		AGE NUMBER);

DROP TABLE ADDRESS;
CREATE TABLE ADDRESS(HOUSE_NO VARCHAR2(90),
		STREET_NAME VARCHAR2(90),
		CITY VARCHAR2(90),
		STATE VARCHAR2(90),
		PERSON_ID NUMBER UNIQUE,
CONSTRAINT ADDRESS_FK1 FOREIGN KEY(PERSON_ID)
		REFERENCES PERSON(ID));

* While making foreign key making unique multiple child records can not be
refered to parent

INSERT INTO PERSON VALUES(1, 'RAMU', 'ABC',22);
INSERT INTO PERSON VALUES(2, 'MANU', 'XYZ',24);
INSERT INTO PERSON VALUES(3, 'SWETHA', 'TEST',21);
INSERT INTO PERSON VALUES(4, 'KUMAR', 'BLR',23);
INSERT INTO PERSON VALUES(5, 'KUMAR', 'BLR',23);


INSERT INTO ADDRESS VALUES('123/B','BTM','BLR','KAR',1);
INSERT INTO ADDRESS VALUES('123/C','BTM','BLR','KAR',1);//ERROR
INSERT INTO ADDRESS VALUES('123/D','BTM','BLR','KAR',2);
INSERT INTO ADDRESS VALUES('123/E','BTM','BLR','KAR',3);
INSERT INTO ADDRESS VALUES('123/F','BTM','BLR','KAR',4);
INSERT INTO ADDRESS VALUES('123/G','BTM','BLR','KAR',6);//ERROR

INSERT INTO ADDRESS(HOUSE_NO, STREET_NAME, CITY, STATE)
		VALUES('123/G','BTM','BLR','KAR');

-if u want to achive 1:1 mapping foreign key should be unique or primary.

SELECT * FROM PERSON;
SELECT * FROM ADDRESS;

SELECT * FROM PERSON WHERE FIRST_NAME = 'RAMU';
SELECT * FROM ADDRESS WHERE HOUSE_NO = '123/D';

SELECT * FROM ADDRESS WHERE PERSON_ID = 3;

providing data from one table finding result of another table
------------------------------------------------------------------

SELECT * FROM ADDRESS WHERE PERSON_ID =
(SELECT ID FROM PERSON WHERE FIRST_NAME = 'RAMU');

SELECT * FROM PERSON WHERE ID = 
(SELECT PERSON_ID FROM ADDRESS WHERE HOUSE_NO = '123/E');

How to read data from both the tables.
------------------------------------------------

SELECT * FROM PERSON, ADDRESS WHERE PERSON.ID = ADDRESS.PERSON_ID;
SELECT * FROM PERSON P, ADDRESS A WHERE P.ID = A.PERSON_ID;

SELECT * FROM PERSON P INNER JOIN ADDRESS A ON P.ID = A.PERSON_ID;
SELECT * FROM PERSON P LEFT OUTER JOIN ADDRESS A ON P.ID = A.PERSON_ID;
SELECT * FROM PERSON P RIGHT OUTER JOIN ADDRESS A ON P.ID = A.PERSON_ID;
SELECT * FROM PERSON P FULL OUTER JOIN ADDRESS A ON P.ID = A.PERSON_ID;

-by defalt join is an inner join ---only intersection of data is coming.
leftouer join---from left side whichever table is joining all te record even no mapping is there.
right oouter join --from right side all the record are coming
full outer join---consider every record from all the table.


20/04/2018
-------------
DROP TABLE PERSON CASCADE CONSTRAINTS;

CREATE TABLE PERSON(ID NUMBER PRIMARY KEY,
		FIRST_NAME VARCHAR2(90),
		LAST_NAME VARCHAR2(90),
		AGE NUMBER);

DROP TABLE MAIL_ACCOUNT;
CREATE TABLE MAIL_ACCOUNT(USERNAME VARCHAR2(90),
		PASSWORD VARCHAR2(90),
		PROVIDER VARCHAR2(90),
		PERSON_ID NUMBER,
CONSTRAINT MK_FK1 FOREIGN KEY(PERSON_ID)
		REFERENCES PERSON(ID));

-if foregin key is not primary or unique it follows 1  :M

The condition for 1:M
---------------------------
-Foreign key should allow dulplicates

INSERT INTO PERSON VALUES(1, 'RAMU', 'ABC', 22);
INSERT INTO PERSON VALUES(2, 'MAMU', 'XYZ', 24);
INSERT INTO PERSON VALUES(3, 'SWETHA', 'TEST', 21);
INSERT INTO PERSON VALUES(4, 'KUMAR', 'BLR', 23);
INSERT INTO PERSON VALUES(5, 'MURALI', 'BLR', 23);


INSERT INTO MAIL_ACCOUNT VALUES('ABC', 'XYZ', 'GMAIL',1);
INSERT INTO MAIL_ACCOUNT VALUES('RAMU', 'XYZ', 'GMAIL',1);
INSERT INTO MAIL_ACCOUNT VALUES('RAMU1', 'XYZ', 'HOTMAIL',1);
INSERT INTO MAIL_ACCOUNT VALUES('MANU', 'XYZ', 'HOTMAIL',2);
INSERT INTO MAIL_ACCOUNT VALUES('MANU', 'XYZ', 'GMAIL',2);
INSERT INTO MAIL_ACCOUNT VALUES('SWETHA', 'XYZ', 'GMAIL',3);
INSERT INTO MAIL_ACCOUNT VALUES('KUMAR', 'XYZ', 'GMAIL',4);
INSERT INTO MAIL_ACCOUNT(USERNAME,PASSWORD,PROVIDER) VALUES
					('USER1', 'XYZ', 'GMAIL');

SELECT * FROM PERSON;

SELECT *  FROM MAIL_ACCOUNT;

SELECT * FROM PERSON WHERE FIRST_NAME = 'RAMU';
SELECT * FROM MAIL_ACCOUNT WHERE USERNAME = 'RAMU1';

SELECT * FROM MAIL_ACCOUNT WHERE PERSON_ID = 3;

SELECT * FROM MAIL_ACCOUNT WHERE PERSON_ID =
	(SELECT ID FROM PERSON WHERE FIRST_NAME = 'RAMU');

SELECT * FROM PERSON WHERE ID =
(SELECT PERSON_ID FROM MAIL_ACCOUNT WHERE USERNAME = 'RAMU');


SELECT * FROM PERSON, MAIL_ACCOUNT WHERE PERSON.ID = MAIL_ACCOUNT.PERSON_ID;
SELECT * FROM PERSON P, MAIL_ACCOUNT M WHERE  P.ID = M.PERSON_ID;

SELECT * FROM PERSON P INNER JOIN MAIL_ACCOUNT M ON P.ID = M.PERSON_ID;
SELECT * FROM PERSON P LEFT OUTER JOIN MAIL_ACCOUNT M ON P.ID =M.PERSON_ID; 
SELECT * FROM PERSON P RIGHT OUTER JOIN MAIL_ACCOUNT M ON P.ID =M.PERSON_ID; 
SELECT * FROM PERSON P FULL OUTER JOIN MAIL_ACCOUNT M ON P.ID =M.PERSON_ID; 


1:1
----------
-foreign key should  be unique or primary key.

M:M
---
DROP TABLE STUDENT CASCADE CONSTRAINTS;
CREATE TABLE STUDENT(ID NUMBER UNIQUE,
		FIRST_NAME VARCHAR2(90),
		LAST_NAME VARCHAR2(90));
DROP TABLE SKILL CASCADE CONSTRAINT;
CREATE TABLE SKILL(ID NUMBER UNIQUE, NAME VARCHAR2(90));
INSERT INTO STUDENT VALUES(1,'RAMU','B');
INSERT INTO STUDENT VALUES(2,'MAMU','C');
INSERT INTO STUDENT VALUES(3,'MURALI','D');
INSERT INTO STUDENT VALUES(4,'KUMAR','E');
INSERT INTO SKILL VALUES(1,'C');
INSERT INTO SKILL VALUES(2,'C++');
INSERT INTO SKILL VALUES(3,'JAVA');
INSERT INTO SKILL VALUES(4,'ORACLE');

DROP TABLE STUDENT_SKILL CASCADE CONSTRAINTS;
CREATE TABLE STUDENT_SKILL(STUDENT_ID NUMBER, SKILL_ID NUMBER,
CONSTRAINT SS_FK1 FOREIGN KEY(STUDENT_ID) REFERENCES STUDENT(ID),
CONSTRAINT SS_FK2 FOREIGN KEY(SKILL_ID) REFERENCES SKILL(ID));

INSERT INTO STUDENT_SKILL VALUES(1,1);
INSERT INTO STUDENT_SKILL VALUES(1,2);
INSERT INTO STUDENT_SKILL VALUES(2,2);
INSERT INTO STUDENT_SKILL VALUES(3,1);
INSERT INTO STUDENT_SKILL VALUES(3,4);

SELECT * FROM STUDENT;

SELECT * FROM SKILL;

SELECT * FROM STUDENT_SKILL;

SELECT NAME FROM SKILL WHERE ID IN
(SELECT SKILL_ID FROM STUDENT_SKILL WHERE STUDENT_ID =
(SELECT ID FROM STUDENT WHERE FIRST_NAME= 'VIJAY'));

SELECT FIRST_NAME FROM STUDENT WHERE ID IN
(SELECT STUDENT_ID FROM STUDENT_SKILL WHERE SKILL_ID=
(SELECT ID FROM SKILL WHERE NAME = 'C'));

SELECT * FROM STUDENT,STUDENT_SKILL, SKILL WHERE
	STUDENT.ID = STUDENT_SKILL.STUDENT_ID AND
	STUDENT_SKILL.SKILL_ID = SKILL.ID;

SELECT * FROM STUDENT S INNER JOIN STUDENT_SKILL SS
ON S.ID = SS.STUDENT_ID INNER JOIN SKILL SK ON SS.SKILL_ID = SK.ID;





















































































